<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>说说缓存穿透、击穿、雪崩的区别</title>
    <link href="/2022/11/01/%E8%AF%B4%E8%AF%B4%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E9%9B%AA%E5%B4%A9%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/11/01/%E8%AF%B4%E8%AF%B4%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E9%9B%AA%E5%B4%A9%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>得分点 三种问题的发生原因以及解决方式 </p><ol><li><p>缓存穿透：是指客户端查询了根本不存在的数据,使得这个请求直达存储层,导致其负载过大甚至造成宕机。这种情况可能是由于业务层误将缓存和库中的数据删除造成的,当然也不排除有人恶意攻击,专门访问库中不存在的数据导致缓存穿透.</p><p>解决方式：</p><p>我们可以通过缓存空对象的方式和布隆过滤器两种方式来解决这一问题：</p><ul><li>缓存空对象是指当存储层未命中后,仍然将空值存入缓存层 ,当客户端再次访问数据时,缓存层直接返回空值。</li><li>将数据存入布隆过滤器,访问缓存之前以过滤器拦截,若请求的数据不存在则直接返回空值。</li></ul></li><li><p>缓存击穿：当一份访问量非常大的热点数据缓存失效的瞬间,大量的请求直达存储层,导致服务崩溃。</p><p>解决方式：</p><ul><li>可以通过热点数据不设置过期时间来解决,这样就不会出现上述的问题,这是“物理”上的永不过期。</li><li>或者为每个数据设置逻辑过期时间,当发现该数据逻辑过期时,使用单独的线程重建缓存。</li><li>除了永不过期的方式,我们也可以通过加互斥锁的方式来解决缓存击穿,即对数据的访问加互斥锁,当一个线程访问该数据时,其他线程只能等待。这个线程访问过后,缓存中的数据将被重建,届时其他线程就可以直接从缓存中取值。</li></ul></li><li><p> 缓存雪崩：是指当某一时刻缓存层无法继续提供服务,导致所有的请求直达存储层,造成数据库宕机。可能是缓存中有大量数据同时过期,也可能是Redis节点发生故障,导致大量请求无法得到处理。</p></li></ol><p>   解决方式：</p><ul><li>第一种是在设置过期时间时,附加一个随机数,避免大量的key同时过期。</li><li>第二种是启用降级和熔断措施,即发生雪崩时,若应用访问的不是核心数据,则直接返回预定义信息/空值/错误信息。或者在发生雪崩时,对于访问缓存接口的请求,客户端并不会把请求发给Redis,而是直接返回。</li><li>第三种是构建高可用的Redis服务,也就是采用哨兵或集群模式,部署多个Redis实例,这样即使个别节点宕机,依然可以保持服务的整体可用。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>说说乐观锁和悲观锁</title>
    <link href="/2022/11/01/%E8%AF%B4%E8%AF%B4%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/"/>
    <url>/2022/11/01/%E8%AF%B4%E8%AF%B4%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/</url>
    
    <content type="html"><![CDATA[<p>得分点 ：乐观锁、悲观锁定义及使用场景</p><ol><li><p>乐观锁：乐观锁总是假设最好的情况,每次去拿数据的时候都认为别人不会修改,所以不会上锁,但是在更新的时候会判断一下在此期间别人有没有去更新这个数据,可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型,这样可以提高吞吐量。</p><p>使用场景：</p><ul><li> GIT,SVN,CVS等代码版本控制管理器,就是一个乐观锁使用很好的场景,例如：A、B程序员,同时从SVN服务器上下载了code.html文件,当A完成提交后,此时B再提交,那么会报版本冲突,此时需要B进行版本处理合并后,再提交到服务器。这其实就是乐观锁的实现全过程。如果此时使用的是悲观锁,那么意味者所有程序员都必须一个一个等待操作提交完,才能访问文件,这是难以接受的。</li></ul></li><li><p>悲观锁：悲观锁总是假设最坏的情况,每次去拿数据的时候都认为别人会修改,所以每次在拿数据的时候都会上锁,这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用,其它线程阻塞,用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制,比如行锁,表锁等,读锁,写锁等,都是在做操作之前先上锁。</p><p>使用场景：</p><ul><li>悲观锁的好处在于可以减少并发,但是当并发量非常大的时候,由于锁消耗资源、锁定时间过长等原因,很容易导致系统性能下降,资源消耗严重。因此一般我们可以在并发量不是很大,并且出现并发情况导致的异常用户和系统都很难以接受的情况下,会选择悲观锁进行。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>说说Redis的持久化策略</title>
    <link href="/2022/11/01/%E8%AF%B4%E8%AF%B4Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5/"/>
    <url>/2022/11/01/%E8%AF%B4%E8%AF%B4Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<p>Reids的持久化方式有两种：RDB和AOF .</p><ol><li><p>RDB: redis database 在指定的时间间隔内，将内存中的数据集的快照写入磁盘，会创建一个二进制文件，文件名以‘.rdb’结尾，内部存储了各个数据库的键值对等信息。</p><p>RDB持久化过程有手动触发和自动触发两种方式：</p><ul><li><p>手动触发：是指通过SAVE或BGSAVE命令触发RDB持久化操作,创建“.rdb”文件。</p></li><li><p>自动触发：是指通过配置选项,让服务器在满足指定条件时自动执行BGSAVE命令。</p></li></ul><p>RDB手动触发分别对应save和bgsave命令：</p><ul><li><p>-save 命令会一直阻塞当前Redis服务器到RBD过程完成为止,所以这种方式在操作内存比较大的实例时会造成长时间阻塞,因此线上环境不建议使用,该命令已经被废弃。</p></li><li><p>-bgsave命令会让Redis进程执行fork创建子进程,由子进程负责RBD持久化过程,完成后自动结束,因此只在fork阶段发生阻塞,一般阻塞的时间也不会很长。</p><p>因此Redis内部所涉及的几乎所有RDB操作都采用了bgsave的方式。</p></li></ul><p>RDB优缺点：</p><ul><li><p>优点：是其生成的文件体积小,使用该文件恢复数据的速度快。（快速）</p></li><li><p>缺点：是BGSAVE每次运行都要执行fork操作创建子进程,因此,RBD没法做到实时的持久化，有时可能会丢失最后一步的数据。（安全性低）</p></li></ul></li><li><p> AOF: append only file 以日志的形式记录每个写操作，只允许追加文件，不允许改写文件，redis启动时会读取这个文件，并从头到尾执行一遍，以此来恢复数据。文件名appendonly.aof 在最恶劣的环境下，也丢失不会超过2秒的数据，完整性较高，但是会对磁盘持续的进行IO，代价太大。企业级最少需要5G才能支持 ，如果.aof文件大小超过原来的一倍，会进行重写压缩，保留最小的指令集合 。</p></li></ol><p>   AOF优缺点：</p><ul><li><p>优点：保证了数据的安全性和完整性，即便是中途宕机，也可以恢复过来。（安全性高）</p></li><li><p>缺点：他的文件比RDB文件大，如果是数据集大的时候，他的恢复速度比RDB文件慢，启动速度也慢。（速度慢）</p></li></ul><ol start="3"><li>RDB-AOF混合持久化：用户可以同时获得RDB持久化和AOF持久化的优点,服务器既可以通过AOF文件包含的RDB数据来实现快速的数据恢复操作,又可以通过AOF文件包含的AOF数据来将丢失数据的时间窗口限制在1s之内 。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis的数据类型</title>
    <link href="/2022/10/31/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2022/10/31/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>​    得分点 Redis5种数据结构 标准回答 Redis主要提供了5种数据结构：字符串(string)、哈希(hash)、列表(list)、集合(set)、有序集合(zset)。Redis还提供了Bitmap、HyperLogLog、Geo类型,但这些类型都是基于上述核心数据类型实现的。一个key对应一个value。</p><ol><li>字符串( string)：可以存储字符串、数字和二进制数据,除了值可以是String以外,所有的键也可以是string,string最大可以存储大小为2M的数据。String结构底层是一个简单动态字符串，支持扩容，存储字符串。</li><li>列表(list)：存储线性有序且可重复的元素，底层数据结构可以是双向链表/压缩列表。相当于一个数组。</li><li>哈希(hash)：存储的是键值对，底层是ziplist和hash。一个大key对应多个小key。</li><li>集合(set)：无序不可重复，底层结构分为inset和HashTable两种。</li><li>有序集合(zset) ：有序不可重复，通过给每个元素设置一个分数来作为排序的依据，底层结构为ziplist和skiplist。为每个元素加了一个score属性（权重）。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一个博客</title>
    <link href="/2022/10/31/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2022/10/31/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h1><ul><li>规划1234</li><li>个国家</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>生</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
